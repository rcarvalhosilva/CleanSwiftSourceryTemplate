{% macro interactorUseCases implemented %}
{% for useCase in type.containedTypes %}
{% for requestType in useCase.containedTypes where requestType.localName == "Request" and requestType|annotated:"method" %}
{% if implemented %}

{% endif %}
    func {{requestType.annotations.method}}(request: {{ requestType.name }}){% if implemented %} {
        {% for responseType in useCase.containedTypes where responseType.localName == "Response" and responseType|annotated:"method" %}
        presenter.{{responseType.annotations.method}}(response: .init())
        {% endfor %}
    } {% endif %}
{% endfor %}
{% endfor %}
{% endmacro %}

{% macro interactorSpyBody %}
{% for useCase in type.containedTypes %}
{% for requestType in useCase.containedTypes where requestType.localName == "Request" and requestType|annotated:"method" %}

    private(set) var {{requestType.annotations.method}}Called = false
    private(set) var {{requestType.annotations.method}}RequestPassed: {{ requestType.name }}?
    func {{requestType.annotations.method}}(request: {{ requestType.name }}) {
        {{requestType.annotations.method}}Called = true
        {{requestType.annotations.method}}RequestPassed = request
    }
{% endfor %}
{% endfor %}
{% endmacro %}

{% macro interactorTestsBody %}
{% for useCase in type.containedTypes %}
{% for requestType in useCase.containedTypes where requestType.localName == "Request" and requestType|annotated:"method" %}
{% for responseType in useCase.containedTypes where responseType.localName == "Response" and responseType|annotated:"method" %}

    func test_{{requestType.annotations.method}}_callsPresenter{{responseType.annotations.method|upperFirstLetter}}() {
        sut.{{requestType.annotations.method}}(request: .init())

        XCTAssertTrue(presenterSpy.{{responseType.annotations.method}}Called)
    }
{% endfor %}
{% endfor %}
{% endfor %}
{% endmacro %}

{% macro presenterUseCases implemented %}
{% for useCase in type.containedTypes %}
{% for responseType in useCase.containedTypes where responseType.localName == "Response" and responseType|annotated:"method" %}
{% if implemented %}

{% endif %}
    func {{responseType.annotations.method}}(response: {{ responseType.name }}){% if implemented %} {
        {% for viewModelType in useCase.containedTypes where viewModelType.localName == "ViewModel" and viewModelType|annotated:"method" %}
        view?.{{viewModelType.annotations.method}}(viewModel: .init())
        {% endfor %}
    } {% endif %}
{% endfor %}
{% endfor %}
{% endmacro %}

{% macro presenterTestsBody %}
{% for useCase in type.containedTypes %}
{% for responseType in useCase.containedTypes where responseType.localName == "Response" and responseType|annotated:"method" %}
{% for viewModelType in useCase.containedTypes where viewModelType.localName == "ViewModel" and viewModelType|annotated:"method" %}

    func test_{{responseType.annotations.method}}_callsView{{viewModelType.annotations.method|upperFirstLetter}}() {
        sut.{{responseType.annotations.method}}(response: .init())

        XCTAssertTrue(viewSpy.{{viewModelType.annotations.method}}Called)
    }
{% endfor %}
{% endfor %}
{% endfor %}
{% endmacro %}

{% macro presenterSpyBody %}
{% for useCase in type.containedTypes %}
{% for responseType in useCase.containedTypes where responseType.localName == "Response" and responseType|annotated:"method" %}

    private(set) var {{responseType.annotations.method}}Called = false
    private(set) var {{responseType.annotations.method}}ResponsePassed: {{ responseType.name }}?
    func {{responseType.annotations.method}}(response: {{ responseType.name }}) {
        {{responseType.annotations.method}}Called = true
        {{responseType.annotations.method}}ResponsePassed = response
    }
{% endfor %}
{% endfor %}
{% endmacro %}

{% macro viewUseCases implemented %}
{% for useCase in type.containedTypes %}
{% for viewModel in useCase.containedTypes where viewModel.localName == "ViewModel" and viewModel|annotated:"method" %}
{% if implemented %}

{% endif %}
    func {{viewModel.annotations.method}}(viewModel: {{ viewModel.name }}){% if implemented %} {} {% endif %}
{% endfor %}
{% endfor %}
{% endmacro %}

{% macro viewSpyBody %}
{% for useCase in type.containedTypes %}
{% for viewModel in useCase.containedTypes where viewModel.localName == "ViewModel" and viewModel|annotated:"method" %}

    private(set) var {{viewModel.annotations.method}}Called = false
    private(set) var {{viewModel.annotations.method}}ViewModelPassed: {{ viewModel.name }}?
    func {{viewModel.annotations.method}}(viewModel: {{ viewModel.name }}) {
        {{viewModel.annotations.method}}Called = true
        {{viewModel.annotations.method}}ViewModelPassed = viewModel
    }
{% endfor %}
{% endfor %}
{% endmacro %}



{% for type in types.based.Scene where type.isExtension == false %}
// sourcery:file:Source/{{ type.name }}Configurator.swift
import UIKit

final class {{ type.name }}Configurator {
    func resolve() -> UIViewController {
        let router = {{ type.name }}Router()
        let presenter = {{ type.name }}Presenter()
        let interactor = {{ type.name }}Interactor(
            router: router,
            presenter: presenter
        )
        let view = {{ type.name }}View()
        let viewController = {{ type.name }}ViewController(
            interactor: interactor,
            view: view
        )

        presenter.view = viewController
        router.viewController = viewController

        return viewController
    }
}
// sourcery:end

// sourcery:file:Tests/{{ type.name }}ConfiguratorTests.swift
import XCTest

final class {{ type.name }}ConfiguratorTests: XCTestCase {
    private let sut = {{ type.name }}Configurator()

    func test_configurator_closesVipCycleWithNoRetainCycle() {
        var viewController = sut.resolve() as? {{ type.name }}ViewController

        XCTAssertNotNil(viewController)

        let interactor = viewController?.interactor as? {{ type.name }}Interactor
        let presenter = interactor?.presenter as? {{ type.name }}Presenter
        let router = interactor?.router as? {{ type.name }}Router

        XCTAssertNotNil(interactor)
        XCTAssertNotNil(presenter)
        XCTAssertNotNil(router)
        XCTAssertTrue(presenter?.view === viewController)

        viewController = nil

        XCTAssertNil(presenter?.view)
    }
}
// sourcery:end

// sourcery:file:Source/{{ type.name }}Interactor.swift
protocol {{ type.name }}BusinessLogic: AnyObject {
    {% call interactorUseCases false%}
}

final class {{ type.name }}Interactor  {
    let router: {{ type.name }}RoutingLogic
    let presenter: {{ type.name }}PresentationLogic

    init(
        router: {{ type.name }}RoutingLogic,
        presenter: {{ type.name }}PresentationLogic
    ) {
      self.router = router
      self.presenter = presenter
    }
}

extension {{ type.name }}Interactor: {{ type.name }}BusinessLogic {
    {% call interactorUseCases true%}
}

// sourcery:end

// sourcery:file:Spies/{{ type.name }}BusinessLogicSpy.swift
final class {{ type.name }}BusinessLogicSpy: {{ type.name }}BusinessLogic {
    {% call interactorSpyBody %}
}
// sourcery:end

// sourcery:file:Tests/{{ type.name }}InteractorTests.swift
import XCTest

final class {{ type.name }}InteractorTests: XCTestCase {
    private let presenterSpy = {{ type.name }}PresentationLogicSpy()
    private let routerSpy = {{ type.name }}RoutingLogicSpy()
    private lazy var sut = {{ type.name }}Interactor(router: routerSpy, presenter: presenterSpy)
    {% call interactorTestsBody %}
}
// sourcery:end

// sourcery:file:Source/{{ type.name }}Presenter.swift
protocol {{ type.name }}PresentationLogic: AnyObject {
    {% call presenterUseCases false%}
}

final class {{ type.name }}Presenter: {{ type.name }}PresentationLogic {
    weak var view: {{ type.name }}DisplayLogic?
    {% call presenterUseCases true%}
}
// sourcery:end

// sourcery:file:Tests/{{ type.name }}PresenterTests.swift
import XCTest

final class {{ type.name }}PresenterTests: XCTestCase {
    private let viewSpy = {{ type.name }}DisplayLogicSpy()
    private lazy var sut: {{ type.name }}Presenter = {
        let presenter = {{ type.name }}Presenter()
        presenter.view = viewSpy
        return presenter
    }()
    {% call presenterTestsBody %}
}
// sourcery:end

// sourcery:file:Spies/{{ type.name }}PresentationLogicSpy.swift
final class {{ type.name }}PresentationLogicSpy: {{ type.name }}PresentationLogic {
    {% call presenterSpyBody %}
}
// sourcery:end

// sourcery:file:Source/{{ type.name }}ViewController.swift
import UIKit

protocol {{ type.name }}DisplayLogic: AnyObject {
    {% call viewUseCases false%}
}

final class {{ type.name }}ViewController: UIViewController, {{ type.name }}DisplayLogic {
    let interactor: {{ type.name }}BusinessLogic
    private let customView: {{ type.name }}Display

    init(
      interactor: {{ type.name }}BusinessLogic,
      view: {{ type.name }}Display
    ) {
        self.interactor = interactor
        self.customView = view
        super.init(nibName: nil, bundle: nil)
    }

    @available(*, unavailable)
    required init?(coder: NSCoder) {
        return nil
    }

    override func loadView() {
        self.view = customView
    }
    {% call viewUseCases true%}
}
// sourcery:end

// sourcery:file:Source/{{ type.name }}View.swift
import Cartography
import CommonColors
import UI
import UIKit

protocol {{ type.name }}Display: UIView, StatefulObject {
}

final class {{ type.name }}View: UIView {
    var currentState: State?

    init() {
        super.init(frame: .zero)
        setup()
    }

    @available(*, unavailable)
    required init?(coder: NSCoder) {
        return nil
    }

    private func setup() {
        backgroundColor = DesignSystem.white.color
    }
}

extension {{ type.name }}View: {{ type.name }}Display {
    func adapt(toState state: State, animated: Bool) {}
}
// sourcery:end

// sourcery:file:Tests/{{ type.name }}ViewTests.swift
import FBSnapshotTestCase

final class {{ type.name }}ViewTests: FBSnapshotTestCase {
    private lazy var sut = {{ type.name }}View()
}
// sourcery:end

// sourcery:file:Spies/{{ type.name }}DisplaySpy.swift
import UI
import UIKit

final class {{ type.name }}DisplaySpy: UIView, {{ type.name }}Display, StatefulObject {
    var currentState: State?

    func adapt(toState state: State, animated: Bool) {}
}
// sourcery:end

// sourcery:file:Tests/{{ type.name }}ViewControllerTests.swift
import XCTest

final class {{ type.name }}ViewControllerTests: XCTestCase {
    private let interactorSpy = {{ type.name }}BusinessLogicSpy()
    private let viewSpy = {{ type.name }}DisplaySpy()
    private lazy var sut = {{ type.name }}ViewController(interactor: interactorSpy, view: viewSpy)
}
// sourcery:end

// sourcery:file:Spies/{{ type.name }}DisplayLogicSpy.swift
final class {{ type.name }}DisplayLogicSpy: {{ type.name }}DisplayLogic {
    {% call viewSpyBody %}
}
// sourcery:end

// sourcery:file:Source/{{ type.name }}Router.swift
protocol {{ type.name }}RoutingLogic {}

final class {{ type.name }}Router: {{ type.name }}RoutingLogic {
    weak var viewController: {{ type.name }}DisplayLogic?
}
// sourcery:end

// sourcery:file:Spies/{{ type.name }}RoutingLogicSpy.swift

final class {{ type.name }}RoutingLogicSpy: {{ type.name }}RoutingLogic {
}
// sourcery:end

// sourcery:file:Tests/{{ type.name }}RouterTests.swift
import XCTest

final class {{ type.name }}RouterTests: XCTestCase {
    private let viewSpy = {{ type.name }}DisplaySpy()
    private lazy var sut: {{ type.name }}Router = {
        let router = {{ type.name }}Router()
        router.viewController = viewSpy
        return router
    }()
}

// sourcery:end

{% endfor %}
